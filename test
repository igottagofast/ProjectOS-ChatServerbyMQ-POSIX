#include <iostream>
#include <mqueue.h>
#include <chrono>
#include <thread>
#include <string>
#include <cstring>
#include <cerrno>
#include <sys/stat.h>
#include <fcntl.h>
#include <mutex>
#include <condition_variable>
#include <unistd.h> // สำหรับ getpid()

std::mutex mtx;
std::condition_variable cv;
std::chrono::high_resolution_clock::time_point send_time;
double total_latency_ms = 0.0;
int received_count = 0;

void listen_queue(const std::string &client_qname)
{
    std::string qname = "/client_" + client_qname;
    struct mq_attr attr;
    attr.mq_flags = 0;
    attr.mq_maxmsg = 10;
    attr.mq_msgsize = 1024;
    attr.mq_curmsgs = 0;

    mqd_t client_q = mq_open(qname.c_str(), O_CREAT | O_RDONLY, 0644, &attr);
    if (client_q == -1)
    {
        perror("mq_open client");
        return;
    }

    char buf[1024];
    while (true)
    {
        ssize_t n = mq_receive(client_q, buf, sizeof(buf), nullptr);
        if (n > 0)
        {
            buf[n] = '\0';
            std::string msg(buf);

            // สมมติว่า server broadcast กลับมา message เดิม
            if (msg.find("message_") != std::string::npos)
            {
                auto end_time = std::chrono::high_resolution_clock::now();
                double latency_ms = std::chrono::duration<double, std::milli>(end_time - send_time).count();

                std::unique_lock<std::mutex> lock(mtx);
                total_latency_ms += latency_ms;
                received_count++;
                cv.notify_one();
            }
        }
    }

    mq_close(client_q);
}

int main()
{
    const int TOTAL_MESSAGES = 100000; // จำนวนข้อความที่ต้องการวัด latency
    std::string CLIENT_NAME = "loadtester_" + std::to_string(getpid());

    // ตั้งค่า queue attributes
    struct mq_attr attr{};
    attr.mq_flags = 0;
    attr.mq_maxmsg = 1000;
    attr.mq_msgsize = 1024;
    attr.mq_curmsgs = 0;

    mqd_t server_q = mq_open("/server", O_WRONLY | O_CREAT, 0644, &attr);
    if (server_q == -1)
    {
        perror("mq_open /server");
        return 1;
    }

    // Register + Join
    std::string reg_msg = "REGISTER:/client_" + CLIENT_NAME;
    mq_send(server_q, reg_msg.c_str(), reg_msg.size() + 1, 0);

    std::string join_msg = "JOIN:" + CLIENT_NAME + ": room1";
    mq_send(server_q, join_msg.c_str(), join_msg.size() + 1, 0);

    std::thread listener_thread(listen_queue, CLIENT_NAME);
    listener_thread.detach();

    std::this_thread::sleep_for(std::chrono::seconds(1)); // รอให้ join เสร็จก่อน

    std::cout << "Starting latency test...\n";

    // จับเวลาเริ่มต้นของการทดสอบทั้งหมด
    auto test_start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i < TOTAL_MESSAGES; ++i)
    {
        std::string msg = "SAY:[" + CLIENT_NAME + "]: message_" + std::to_string(i);

        // จับเวลาเริ่มก่อนส่ง
        send_time = std::chrono::high_resolution_clock::now();

        if (mq_send(server_q, msg.c_str(), msg.size() + 1, 0) == -1)
        {
            perror("mq_send");
            continue;
        }

        // รอจนกว่าจะได้รับข้อความตอบกลับจาก listener
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, []
                { return received_count > 0; });
        received_count = 0; // reset
    }

    // จับเวลาสิ้นสุดของการทดสอบทั้งหมด
    auto test_end = std::chrono::high_resolution_clock::now();

    // คำนวณเวลารวมและ throughput
    std::chrono::duration<double> total_time = test_end - test_start;
    double throughput = TOTAL_MESSAGES / total_time.count();
    double avg_latency = total_latency_ms / TOTAL_MESSAGES;

    // แสดงผล
    std::cout << "--------------------------------\n";
    std::cout << "Messages: " << TOTAL_MESSAGES << "\n";
    std::cout << "Total time: " << total_time.count() << " sec\n";
    std::cout << "Throughput: " << throughput << " msg/sec\n";
    std::cout << "Average latency: " << avg_latency << " ms\n";
    std::cout << "--------------------------------\n";

    mq_close(server_q);
    return 0;
}

